import indexTsx from './index.tsx?raw'
import { CodeOrSourceMdx } from '@storybook/addon-docs/blocks'

# useRafTimeout

管理 requestAnimationFrame 的 timeout Hook，使用 requestAnimationFrame 实现的延时执行，更加流畅。

## 详细介绍

`useRafTimeout` 是基于 requestAnimationFrame 实现的延时 Hook，相比 setTimeout 更加流畅且节能。

**涉及的知识点**：
- requestAnimationFrame API
- 后台标签页优化

**常用场景**：
- 需要流畅动画效果的延时任务
- 替代 setTimeout 实现更平滑的延时
- 与屏幕刷新率同步的一次性操作

**优势**：
- 与屏幕刷新同步
- 后台标签页自动暂停

## 演示代码

<CodeOrSourceMdx language="tsx">
  {indexTsx}
</CodeOrSourceMdx>

## 参数介绍

<table>
  <thead>
    <tr>
      <th>参数名</th>
      <th>类型</th>
      <th>默认值</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>fn</td>
      <td><code>() =&gt; void</code></td>
      <td>-</td>
      <td>执行函数</td>
    </tr>
    <tr>
      <td>delay</td>
      <td><code>number | undefined</code></td>
      <td>-</td>
      <td>延迟时间（毫秒），设置为 undefined 停止定时器</td>
    </tr>
  </tbody>
</table>

## 返回值

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>() =&gt; void</code></td>
      <td>清除定时器函数</td>
    </tr>
  </tbody>
</table>

## 与 setTimeout 对比

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>useRafTimeout</th>
      <th>setTimeout</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>帧同步</td>
      <td>✅ 与屏幕刷新同步</td>
      <td>❌ 不同步</td>
    </tr>
    <tr>
      <td>性能</td>
      <td>✅ 后台自动暂停</td>
      <td>❌ 始终执行</td>
    </tr>
    <tr>
      <td>精度</td>
      <td>受帧率影响</td>
      <td>更精确</td>
    </tr>
    <tr>
      <td>适用场景</td>
      <td>动画、UI 更新</td>
      <td>精确计时</td>
    </tr>
  </tbody>
</table>

## 与 useRafInterval 对比

<table>
  <thead>
    <tr>
      <th>Hook</th>
      <th>执行次数</th>
      <th>适用场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>useRafTimeout</code></td>
      <td>执行一次</td>
      <td>一次性延时任务</td>
    </tr>
    <tr>
      <td><code>useRafInterval</code></td>
      <td>循环执行</td>
      <td>周期性任务</td>
    </tr>
  </tbody>
</table>

## 具体实现原理

### 文件职责

- `index.ts`：实现 `useRafTimeout` Hook，基于 `requestAnimationFrame` 实现一次性延时执行

### 核心流程

1. 使用 `useRef` 保存最新的回调函数（`fnRef.current = fn`），每次渲染直接赋值
2. 使用 `useRef` 保存定时器 ID（`timerRef`）和起始时间戳（`startTimeRef`）
3. 通过 `useCallback` 创建稳定的 `clear` 函数，用于取消 RAF
4. 在 `useEffect` 中判断 delay 有效性，有效则启动 RAF 循环
5. 当累计时间 `elapsed >= delay` 时执行回调并调用 `clear()` 停止循环

### 关键技术点

- **`useRef` 保存回调**：`fnRef.current = fn` 每次渲染直接赋值（非 `useLatest`），确保延时回调中始终调用最新函数
- **一次性执行**：与 `useRafInterval` 的区别在于 `elapsed >= delay` 后执行回调并调用 `clear()` 终止循环，不再继续 RAF
- **时间戳比较**：通过 `timestamp - startTimeRef.current >= delay` 判断是否达到延迟
- **`isNumber` 守卫**：使用 `isNumber(delay) && delay >= 0` 判断有效性

### 数据流向

```
fn → fnRef.current（每次渲染更新）
delay → useEffect 依赖
       ↓
useEffect 启动 → requestAnimationFrame(loop)
       ↓
loop(timestamp) → elapsed >= delay? → fnRef.current() → clear() → 结束
                                    → 否 → requestAnimationFrame(loop) → 继续等待
       ↓
返回 clear 函数 → cancelAnimationFrame
```
