import basicDemo from './basicDemo?raw'
import leadingDemo from './leadingDemo?raw'
import cancelDemo from './cancelDemo?raw'
import { CodeOrSourceMdx } from '@storybook/addon-docs/blocks'

# createDebounceFn

创建防抖函数的工具，用于限制函数的执行频率。

## 详细介绍

`createDebounceFn` 是一个创建防抖函数的工厂函数。防抖（debounce）是一种优化技术，用于确保函数在一定时间内只执行一次，通常在连续触发事件时，只在最后一次触发后的指定延迟时间后执行。

常用场景：
- 搜索框输入：用户停止输入后才发起搜索请求
- 窗口 resize：用户停止调整窗口后才执行布局计算
- 按钮防重复点击：防止用户快速点击导致多次提交

## 基础防抖

默认情况下，防抖函数会在最后一次调用后的等待时间结束时执行（trailing 模式）。

<CodeOrSourceMdx language="typescript">
  {basicDemo}
</CodeOrSourceMdx>

## Leading 模式

设置 `leading: true` 后，函数会在第一次调用时立即执行，后续调用在等待时间内被忽略。

<CodeOrSourceMdx language="typescript">
  {leadingDemo}
</CodeOrSourceMdx>

## 取消防抖

可以调用 `cancel()` 方法取消待执行的防抖函数。

<CodeOrSourceMdx language="typescript">
  {cancelDemo}
</CodeOrSourceMdx>

## 参数介绍

<table>
  <thead>
    <tr>
      <th>参数名</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>fn</td>
      <td><code>T extends (...args: any[]) =&gt; any</code></td>
      <td>要防抖的函数</td>
    </tr>
    <tr>
      <td>wait</td>
      <td><code>number</code></td>
      <td>等待时间（毫秒），默认 1000</td>
    </tr>
    <tr>
      <td>options.leading</td>
      <td><code>boolean</code></td>
      <td>是否在延迟开始前调用，默认 false</td>
    </tr>
    <tr>
      <td>options.trailing</td>
      <td><code>boolean</code></td>
      <td>是否在延迟结束后调用，默认 true</td>
    </tr>
    <tr>
      <td>options.maxWait</td>
      <td><code>number</code></td>
      <td>最大等待时间（毫秒）</td>
    </tr>
  </tbody>
</table>

## 返回值

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>debouncedFn</td>
      <td><code>DebouncedFn&lt;T&gt;</code></td>
      <td>防抖后的函数</td>
    </tr>
    <tr>
      <td>debouncedFn.cancel</td>
      <td><code>() =&gt; void</code></td>
      <td>取消待执行的防抖函数</td>
    </tr>
    <tr>
      <td>debouncedFn.flush</td>
      <td><code>() =&gt; ReturnType&lt;T&gt;</code></td>
      <td>立即执行防抖函数</td>
    </tr>
  </tbody>
</table>

## 具体实现原理

1. **文件职责**: `index.ts` 包含防抖函数的完整实现和类型定义
2. **核心流程**: 
   - 调用时记录参数和时间戳
   - 通过 setTimeout 延迟执行
   - 支持 leading（前置执行）和 trailing（后置执行）两种模式
3. **关键技术点**: 
   - 使用闭包保存状态（定时器 ID、最后调用时间等）
   - 通过 `shouldInvoke` 判断是否应该执行
   - 支持 `maxWait` 确保长时间连续调用时也能执行
4. **数据流向**: 调用 → 记录参数 → 设置定时器 → 定时器触发时执行原函数
