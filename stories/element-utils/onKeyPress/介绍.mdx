import indexDemo from './index.tsx?raw'
import { CodeOrSourceMdx } from '@storybook/addon-docs/blocks'

# onKeyPress

监听键盘按键事件的工具函数。

## 详细介绍

`onKeyPress` 是一个用于监听特定键盘按键事件的工具函数，它封装了原生的 `keydown`、`keyup`、`keypress` 事件监听逻辑，提供了更简洁的 API 和更强大的功能支持。

**核心特性**：
- **按键匹配**：支持 `event.key`（如 `'Escape'`）或 `event.code`（如 `'KeyS'`）两种匹配方式
- **多键监听**：支持同时监听多个按键，传入数组即可
- **修饰键组合**：支持 Ctrl、Alt、Shift、Meta（Mac Command）修饰键组合
- **事件类型**：支持 `keydown`、`keyup`、`keypress` 三种事件类型
- **自定义目标**：可指定监听的 DOM 元素，默认为 `window`

**常用场景**：
- 快捷键监听（如 Ctrl+S 保存、Ctrl+Z 撤销）
- 导航键监听（如方向键控制）
- Escape 键关闭弹窗/模态框
- 游戏键盘控制
- 表单输入增强（如 Enter 提交）

## 使用示例

<CodeOrSourceMdx language="tsx">
  {indexDemo}
</CodeOrSourceMdx>

## 参数介绍

<table>
  <thead>
    <tr>
      <th>参数名</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>key</td>
      <td><code>string | string[]</code></td>
      <td>要监听的按键，支持 event.key（如 'Escape'）或 event.code（如 'KeyS'）</td>
    </tr>
    <tr>
      <td>callback</td>
      <td><code>(event: KeyboardEvent) =&gt; void</code></td>
      <td>按键触发时的回调函数</td>
    </tr>
    <tr>
      <td>options</td>
      <td><code>OnKeyPressOptions</code></td>
      <td>可选配置项</td>
    </tr>
    <tr>
      <td>options.type</td>
      <td><code>'keydown' | 'keyup' | 'keypress'</code></td>
      <td>键盘事件类型，默认 'keydown'</td>
    </tr>
    <tr>
      <td>options.target</td>
      <td><code>EventTarget</code></td>
      <td>事件监听目标，默认 window</td>
    </tr>
    <tr>
      <td>options.modifiers</td>
      <td><code>KeyModifiers</code></td>
      <td>修饰键要求配置</td>
    </tr>
  </tbody>
</table>

## KeyModifiers 类型

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ctrl</td>
      <td><code>boolean</code></td>
      <td>是否需要按住 Ctrl 键</td>
    </tr>
    <tr>
      <td>alt</td>
      <td><code>boolean</code></td>
      <td>是否需要按住 Alt 键</td>
    </tr>
    <tr>
      <td>shift</td>
      <td><code>boolean</code></td>
      <td>是否需要按住 Shift 键</td>
    </tr>
    <tr>
      <td>meta</td>
      <td><code>boolean</code></td>
      <td>是否需要按住 Meta 键（Mac 上的 Command 键）</td>
    </tr>
  </tbody>
</table>

## 返回值

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>() =&gt; void</code></td>
      <td>清理函数，调用后停止监听键盘事件</td>
    </tr>
  </tbody>
</table>

## 具体实现原理

**文件职责**：
- `index.ts`：主入口文件，实现 `onKeyPress` 监听逻辑，同时作为模块统一出口，re-export `core/` 下的共享工具
- `interface.ts`：TypeScript 类型定义，包含 `onKeyPress` 自身类型（`CleanupFn`、`OnKeyPressOptions`、`KeyModifiers`）以及键盘共享类型（`KeyType`、`KeyFilter`、`KeyPredicate`）
- `core/aliasKeyCodeMap.ts`：键盘按键别名与 keyCode 的映射表
- `core/modifierKey.ts`：修饰键检测映射
- `core/genFilterKey.ts`：按键匹配核心逻辑
- `core/genKeyFormatter.ts`：将 `KeyFilter` 预处理为统一的 `KeyPredicate` 判断函数

**模块依赖链**：
```
aliasKeyCodeMap ← modifierKey ← genFilterKey ← genKeyFormatter
```

### `onKeyPress` 核心流程

1. **`isBrowser()` 环境检查**：因为该工具可能在 SSR（Node.js）环境中被引用，此时 `window` 不存在，直接返回空函数避免报错
2. **将按键参数统一为数组**：API 允许传入 `string | string[]`，内部统一转为数组后用 `includes` 匹配，简化后续判断逻辑
3. **先检查修饰键，再匹配按键**：修饰键检查是前置条件，不满足时直接 `return` 可以避免不必要的按键匹配计算
4. **同时匹配 `event.key` 和 `event.code`**：`event.key` 返回的是按键字符（受键盘布局影响），`event.code` 返回的是物理按键码（不受布局影响），两者都检查可以兼容不同键盘布局和不同浏览器的行为差异
5. **通过 `createEventListener` 注册监听**：封装了 `addEventListener` / `removeEventListener` 的配对操作，返回清理函数，调用方无需手动管理事件解绑

### `core/` 共享工具实现细节

**`aliasKeyCodeMap`**：
- 提供 102 项按键别名到 `keyCode` 的映射（如 `'enter'` → `13`、`'esc'` → `27`），因为原生 `event.keyCode` 是数字，而用户更习惯用字符串别名（`'ctrl.s'`）来描述按键，需要一个映射表来桥接
- `meta` 键在 Mac 上对应左 Command（keyCode 91）和右 Command（keyCode 93），在 Windows 上对应左 Win（91）和右 Win（92），因此通过 `isAppleDevice()` 动态返回不同的 keyCode 数组

**`modifierKey`**：
- 对 `ctrl`、`shift`、`alt` 直接使用 `event.ctrlKey` 等布尔属性即可检测
- `meta` 键的 `keyup` 事件需要特殊处理：浏览器在 `keyup` 时 `event.metaKey` 可能已经为 `false`（因为 meta 键本身就是被释放的键），所以改用 `event.keyCode` 与 `aliasKeyCodeMap.meta` 比对来兜底

**`genFilterKey`**——判断一次键盘事件是否匹配指定的按键过滤器，匹配成功返回 `keyFilter` 本身，失败返回 `false`：
1. **空事件守卫**：浏览器自动补全 input 时会触发 `keyDown`/`keyUp`，但 `event.key` 为空，直接跳过
2. **数字类型快速路径**：如果 `keyFilter` 是数字（如 `13`），直接与 `event.keyCode` 比对，最简单的匹配方式
3. **字符串组合键解析**：按 `.` 拆分字符串（如 `'ctrl.s'` → `['ctrl', 's']`），逐段匹配：
   - 先查 `modifierKey[key]`——如果是修饰键（`ctrl`/`shift`/`alt`/`meta`），调用对应的检测函数判断该修饰键是否处于按下状态
   - 再查 `aliasKeyCodeMap[key]`——将别名（如 `'s'`）映射为 keyCode（`83`），与 `event.keyCode` 比对
   - 两者满足其一就算该段匹配成功，计数 +1
4. **最终判定**：
   - **非精确模式**：只要所有段都匹配就算成功。比如用户按了 `Ctrl+Shift+S`，过滤器是 `'ctrl.s'`，也能匹配
   - **精确模式**：额外要求 `countKeyByEvent(event)` 统计的激活按键数量恰好等于过滤器段数，这样 `Ctrl+Shift+S` 就不会匹配 `'ctrl.s'`（激活了 3 个键，但过滤器只有 2 段）

**`countKeyByEvent`**——统计当前事件中实际激活的按键数量，服务于精确匹配：
- 遍历四个修饰键检测函数，累加处于激活状态的修饰键数量
- keyCode `[16,17,18,91,92]` 是修饰键本身的物理键码，如果用户按的恰好就是修饰键，则不额外 +1；否则在修饰键数量基础上 +1（代表被按下的普通键）

**`genKeyFormatter`**：
- `KeyFilter` 支持多种输入格式（函数、单键、数组），但事件回调内部需要统一的判断接口，因此 `genKeyFormatter` 将所有格式标准化为 `KeyPredicate` 函数
- 函数类型直接透传；单键类型包装为调用 `genFilterKey` 的闭包；数组类型遍历每个元素调用 `genFilterKey`，找到第一个匹配项即返回
