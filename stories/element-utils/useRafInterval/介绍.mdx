import indexTsx from './index.tsx?raw'
import { CodeOrSourceMdx } from '@storybook/addon-docs/blocks'

# useRafInterval

管理 requestAnimationFrame 的 interval Hook，使用 requestAnimationFrame 实现的定时器，更加流畅。

## 详细介绍

`useRafInterval` 是基于 requestAnimationFrame 实现的定时器 Hook，相比 setInterval 更加流畅且节能。

**涉及的知识点**：
- requestAnimationFrame API：与浏览器刷新率同步
- 后台标签页优化：浏览器会自动暂停后台标签页的 RAF

**常用场景**：
- 需要流畅动画效果的定时任务
- 替代 setInterval 实现更平滑的更新
- 与屏幕刷新率同步的定时操作

**优势**：
- 与屏幕刷新同步，动画更流畅
- 后台标签页自动暂停，节省资源
- 支持 immediate 选项

## 演示代码

<CodeOrSourceMdx language="tsx">
  {indexTsx}
</CodeOrSourceMdx>

## 参数介绍

<table>
  <thead>
    <tr>
      <th>参数名</th>
      <th>类型</th>
      <th>默认值</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>fn</td>
      <td><code>() =&gt; void</code></td>
      <td>-</td>
      <td>执行函数</td>
    </tr>
    <tr>
      <td>delay</td>
      <td><code>number | undefined</code></td>
      <td>-</td>
      <td>间隔时间（毫秒），设置为 undefined 停止定时器</td>
    </tr>
    <tr>
      <td>options.immediate</td>
      <td><code>boolean</code></td>
      <td><code>false</code></td>
      <td>是否在首次渲染时立即执行</td>
    </tr>
  </tbody>
</table>

## 返回值

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>() =&gt; void</code></td>
      <td>清除定时器函数</td>
    </tr>
  </tbody>
</table>

## 与 setInterval 对比

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>useRafInterval</th>
      <th>setInterval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>帧同步</td>
      <td>✅ 与屏幕刷新同步</td>
      <td>❌ 不同步</td>
    </tr>
    <tr>
      <td>性能</td>
      <td>✅ 后台自动暂停</td>
      <td>❌ 始终执行</td>
    </tr>
    <tr>
      <td>精度</td>
      <td>受帧率影响</td>
      <td>更精确</td>
    </tr>
    <tr>
      <td>适用场景</td>
      <td>动画、UI 更新</td>
      <td>精确计时</td>
    </tr>
  </tbody>
</table>

## 具体实现原理

### 文件职责

- `index.ts`：实现 `useRafInterval` Hook，基于 `requestAnimationFrame` 递归调用模拟 interval 定时器

### 核心流程

1. 使用 `useRef` 保存最新的回调函数（`fnRef.current = fn`），每次渲染直接赋值
2. 使用 `useRef` 保存定时器 ID（`timerRef`）和起始时间戳（`startTimeRef`）
3. 通过 `useCallback` 创建稳定的 `clear` 函数，用于取消 RAF
4. 在 `useEffect` 中判断 delay 有效性，有效则启动 RAF 循环，返回 `clear` 作为清理函数
5. 若 `immediate` 为 true，在启动循环前立即执行一次回调

### 关键技术点

- **`useRef` 保存回调**：`fnRef.current = fn` 每次渲染直接赋值（非 `useLatest`），确保 RAF 回调中始终调用最新函数
- **递归 RAF 调用**：`loop` 函数内部调用 `requestAnimationFrame(loop)` 形成循环
- **时间戳比较**：通过 `timestamp - startTimeRef.current >= delay` 判断是否达到间隔，达到后重置起始时间
- **`isNumber` 守卫**：使用 `isNumber(delay) && delay >= 0` 判断有效性，delay 为 undefined 时不启动定时器

### 数据流向

```
fn → fnRef.current（每次渲染更新）
delay/immediate → useEffect 依赖
       ↓
useEffect 启动 → immediate? → fnRef.current()
       ↓
requestAnimationFrame(loop)
       ↓
loop(timestamp) → elapsed >= delay? → fnRef.current() → 重置 startTime → 继续 RAF
                                    → 否 → 继续 RAF
       ↓
返回 clear 函数 → cancelAnimationFrame
```
