import { CodeOrSourceMdx } from '@storybook/addon-docs/blocks'
import indexTsx from './index.tsx?raw'

# usePrevious

获取状态上一次值的 Hook。

## 详细介绍

`usePrevious` 返回一个元组 `[prevRef, update]`，其中 `prevRef` 是保存上一次值的 ref，`update` 是手动触发更新的函数。与自动跟踪不同，只有显式调用 `update` 时才会将当前值存为上一次值，给予调用方完全的控制权。

**使用场景**：
- 比较状态前后变化（如动画过渡）
- 需要精确控制"何时记录上一次值"的场景
- 撤销/重做功能中记录历史状态
- 表单变化检测（只在提交时记录）

## 演示代码

<CodeOrSourceMdx language="tsx">
  {indexTsx}
</CodeOrSourceMdx>

## 参数介绍

<table>
  <thead>
    <tr>
      <th>参数名</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>state</td>
      <td><code>T</code></td>
      <td>需要跟踪的状态值</td>
    </tr>
  </tbody>
</table>

## 返回值

<table>
  <thead>
    <tr>
      <th>索引</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[0]</td>
      <td><code>RefObject&lt;T | undefined&gt;</code></td>
      <td>上一次的状态值 ref，通过 .current 读取，首次为 undefined</td>
    </tr>
    <tr>
      <td>[1]</td>
      <td><code>() =&gt; void</code></td>
      <td>更新函数，调用后将当前 state 存为上一次值</td>
    </tr>
  </tbody>
</table>

## 具体实现原理

**文件职责**：
- `index.ts`：实现 `usePrevious` Hook

**核心流程**：
1. 使用 `prevRef` 保存上一次值，`curRef` 保存当前值（初始为传入的 `state`）
2. 通过 `useCallback` 创建 `update` 函数，依赖 `[state]`：调用时将 `curRef.current` 赋给 `prevRef.current`，再将 `state` 赋给 `curRef.current`
3. 返回 `[prevRef, update]` 元组

**关键技术点**：
- **返回 ref 而非值**：`prevRef` 是 ref 对象，读取时通过 `.current` 访问，不会触发重渲染，避免了旧版实现中 `useState` 导致的额外渲染
- **手动控制更新时机**：调用方决定何时调用 `update`，比自动在 `useEffect` 中更新更灵活。例如可以在 `setState` 之前先调用 `update` 记录当前值，也可以跳过某些变化不记录
- **`useCallback` 依赖 `[state]`**：确保 `update` 内部总能捕获到最新的 `state` 值写入 `curRef`
