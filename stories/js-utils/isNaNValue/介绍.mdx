import isNaNValueDemo from './isNaNValueDemo?raw'
import edgeCaseDemo from './edgeCaseDemo?raw'
import { CodeOrSourceMdx } from '@storybook/addon-docs/blocks'

# isNaNValue

检查 value 是否是 NaN

## 详细介绍

`isNaNValue` 用于精确判断一个值是否为 `NaN`。

### NaN 的特殊性

`NaN`（Not a Number）是 JS 中最特殊的值，它有一个独一无二的特性：**NaN 是唯一一个不等于自身的值**。

```js
NaN === NaN   // false ← 违反直觉，但这是 IEEE 754 浮点数标准的规定
NaN !== NaN   // true  ← 利用这个特性可以判断 NaN
```

JS 中没有任何其他值满足 `value !== value`：
```js
0 !== 0             // false
'' !== ''           // false
null !== null       // false
undefined !== undefined  // false
```

### 为什么不用全局 `isNaN()`？

全局 `isNaN()` 会先把参数**隐式转换为数字**，导致误判：

```js
isNaN('hello')     // true ← 'hello' 先转成 Number('hello') → NaN
isNaN(undefined)   // true ← undefined 先转成 Number(undefined) → NaN
isNaN({})          // true ← {} 先转成 Number({}) → NaN
```

而 `isNaNValue` 先用 `typeof === 'number'` 过滤，只有真正的数字类型 `NaN` 才会返回 `true`：

```js
isNaNValue('hello')     // false ← typeof 'hello' 是 'string'，直接排除
isNaNValue(undefined)   // false ← typeof undefined 是 'undefined'
isNaNValue(NaN)         // true  ← typeof NaN 是 'number'，且 NaN !== NaN
```

> `Number.isNaN()` 也能精确判断，但 `isNaNValue` 兼容性更好（不依赖 ES6）。

## 基础用法

点击按钮查看 `isNaNValue` 的基本使用效果。

<CodeOrSourceMdx language="typescript">
  {isNaNValueDemo}
</CodeOrSourceMdx>

## 边界情况验证

验证各种边界条件下的行为表现。

<CodeOrSourceMdx language="typescript">
  {edgeCaseDemo}
</CodeOrSourceMdx>

## 参数介绍

<table>
  <thead>
    <tr>
      <th>参数名</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>value</td>
      <td><code>unknown</code></td>
      <td>要检查的值</td>
    </tr>
  </tbody>
</table>

### 返回值

- 类型：`boolean`
- 描述：如果是 NaN，返回 true

## 具体实现原理

实现只有一行：`typeof value === 'number' && value !== value`

分两步判断：
1. **`typeof value === 'number'`**：确保是数字类型，排除字符串、对象等（`typeof NaN` 结果是 `'number'`）
2. **`value !== value`**：利用 NaN 不等于自身的特性，只有 NaN 满足这个条件

两个条件缺一不可：
- 只有第一步 → `typeof 123 === 'number'` 也成立，会误判正常数字
- 只有第二步 → 理论上够用，但加 typeof 是为了类型收窄，让 TS 更安全
