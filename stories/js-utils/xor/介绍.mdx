import xorDemo from './xorDemo?raw'
import xorByDemo from './xorByDemo?raw'
import { CodeOrSourceMdx } from '@storybook/addon-docs/blocks'

# xor

创建对称差集数组。

## 详细介绍

`xor` 创建对称差集（仅在一个数组中出现的元素）。`xorBy` 支持迭代器，`xorWith` 支持比较器。

**常用场景**：
- 查找两个集合的差异
- 数据比对
- 切换选中状态

## 对称差集

使用 `xor` 创建仅在一个数组中出现的元素组成的数组。

<CodeOrSourceMdx language="typescript">
  {xorDemo}
</CodeOrSourceMdx>

## xorBy 和 xorWith

使用 `xorBy`（按迭代器）和 `xorWith`（按比较器）计算对称差集。

<CodeOrSourceMdx language="typescript">
  {xorByDemo}
</CodeOrSourceMdx>

## 参数介绍

<table>
  <thead>
    <tr>
      <th>参数名</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>...arrays</td>
      <td><code>T[][]</code></td>
      <td>要比较的数组</td>
    </tr>
    <tr>
      <td>iteratee</td>
      <td><code>(value: T) => K</code></td>
      <td>迭代器（xorBy 使用）</td>
    </tr>
    <tr>
      <td>comparator</td>
      <td><code>(a, b) => boolean</code></td>
      <td>比较器（xorWith 使用）</td>
    </tr>
  </tbody>
</table>

### 返回值

- 类型：`T[]`
- 描述：对称差集数组

## 具体实现原理

### 什么是对称差集？

对称差集（Symmetric Difference）是集合论概念，记作 **A △ B**，表示**只属于其中一个集合、不同时属于多个集合**的元素：

```
A △ B = (A - B) ∪ (B - A)
```

用韦恩图理解：两个圆的**非重叠部分**。

<table>
  <thead>
    <tr>
      <th>A</th>
      <th>B</th>
      <th>交集（排除）</th>
      <th>对称差集（保留）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>[2, 1]</code></td>
      <td><code>[2, 3]</code></td>
      <td><code>[2]</code></td>
      <td><code>[1, 3]</code></td>
    </tr>
    <tr>
      <td><code>[1, 2, 3]</code></td>
      <td><code>[2, 3, 4]</code></td>
      <td><code>[2, 3]</code></td>
      <td><code>[1, 4]</code></td>
    </tr>
  </tbody>
</table>

支持多个数组：`xor(A, B, C)` 中，只在**恰好一个**数组中出现的元素才会被保留。

### 实现步骤

#### 第一步：统计每个值出现在几个数组中

```typescript
const countMap = new Map<T, number>()  // key=值, value=出现在几个数组中

for (const array of arrays) {
  const seen = new Set<T>()            // 同一数组内去重
  for (const value of array) {
    if (!seen.has(value)) {
      seen.add(value)
      countMap.set(value, (countMap.get(value) || 0) + 1)
    }
  }
}
```

注意这里统计的是"出现在**几个数组**中"，而不是"出现了几次"。`seen` 确保同一数组内的重复元素（如 `[2, 2, 1]` 中的两个 `2`）只计数一次。

以 `xor([2, 1], [2, 3])` 为例：

<table>
  <thead>
    <tr>
      <th>遍历阶段</th>
      <th>值</th>
      <th>countMap 变化</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>数组1 <code>[2, 1]</code></td>
      <td><code>2</code></td>
      <td><code>{'{{2: 1}}'}</code></td>
    </tr>
    <tr>
      <td></td>
      <td><code>1</code></td>
      <td><code>{'{{2: 1, 1: 1}}'}</code></td>
    </tr>
    <tr>
      <td>数组2 <code>[2, 3]</code></td>
      <td><code>2</code></td>
      <td><code>{'{{2: 2, 1: 1}}'}</code>（2 在第二个数组也出现，计数变为 2）</td>
    </tr>
    <tr>
      <td></td>
      <td><code>3</code></td>
      <td><code>{'{{2: 2, 1: 1, 3: 1}}'}</code></td>
    </tr>
  </tbody>
</table>

#### 第二步：筛选 count === 1 的元素

```typescript
for (const [value, count] of countMap) {
  if (count === 1) result.push(value)
}
```

`count === 1` 表示该值只在一个数组中出现过——正是对称差集的定义。

从上面的 countMap 中：
- `2` → count=2（出现在两个数组中）→ 排除
- `1` → count=1 → 保留
- `3` → count=1 → 保留

最终结果：`[1, 3]`
